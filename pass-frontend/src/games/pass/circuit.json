{
  "noir_version": "0.33.0+325dac54efb6f99201de9fdeb0a507d45189607d",
  "hash": 11870454696787143000,
  "abi": {
    "parameters": [
      {
        "name": "secret",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        },
        "visibility": "private"
      },
      {
        "name": "salt",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "guess",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        },
        "visibility": "private"
      },
      {
        "name": "hash",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "acertos",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "permutados",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "erros",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "tuple",
        "fields": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "kind": "field"
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "visibility": "public"
    },
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "nZvdThpRFEbfZa65OPvn/PEqTdNQxYbEoFFs0hjfvdAW2nLmzDDrEmXhybic79sbeR/ut1/fvn3Z7R+eXof1p/fh8eluc9g97Y+P3of660uvz5v96dHrYfNyGNZZ0mrY7u+HdfH6sRoedo/bYR3zx6p5qtbgf56r1f3yZM0fn1eDhLGXL0nPL1/s35c/ETJGiOTzTxGp8ZpRwBhgHDBxlNFYz4y21yABJgOmAKbOM+WK0QAYWX42VcAYYBwwwAMFHijwQIEHWpczFgADPDDggQEPDHhgwAMDHhjwwIAHBjxw4IEDDxx44MADBx448MDHPbBwjlMx9WsmA6bMM/WaqcuZGJafLQpgFDAGGAdMBAzwIAIPYgFMXc4k4EECHiTgQQIeJOBBAh4IKqSdRjoDJQJlApFSKiCFhNRSuaWXtpCS4xmBnEBkRiHlVEg7FVJPhfRTIQVVSEMVUlGFdFQhJVVISxVSU4X0VDEQTGIgmcRviKbaQEIgJcczAjmBSD6RwiqksYoTI5wYQUqrkNYqpLYK6a1CiquQ5iqkugrprtIpryrhcmPRJqg77XUa6tTXGUgAVOvyQqUhEEgIpASy5RdCgxOIrOAC2cGFG0KtPV4hEKg5KoFAZCErZCMrZCUrZCdLlvNKtvNK1vNKRiElo5AqMYKt6IkRaEmPtvQKQk01EeiGUKsNVAgEao5aIJAQSAlkBHICESOMGGGZQIVAxAgnRjgxgoxCSkYhJaOQ9lb3k+WjMwrNQJlAhUCg+GoExffYYUYhL5eSGENooPHjRbncy6M1v6c6fryY8gXKLSQEUgIZgRxcvRoJlAiUCUSM6IxCk5B1RqEZSJa7ZwEYYcEI5ASKBErk6mUCFQIRI4QY0RmFZqCOEf4Xqu0/PxiBnBwvAss7o9C0Rp1RaAYqBKoAUmKEEiM6o9AMZAQiRmgkUALCdkahGYjcIxT0CDPQI8yEQCQ1jKSGESOMGGEkNYykhhEjjKRGZxSaFrYzCs1A5B7RGYWmLXfSI5z0CCep4SQ1nBjhxIhIUiOS1IjEiEhSo/Ou0LSwnXeFZiByj+i8KzRteSQ9IpIekUhqJJIaiRiRiBGJpEYiqZGIEYmkRipA2FQBlMk9IpPpM5MekUmPyCQ1MkmNTIzIxIhMUiOT1CjEiEJSo5Dps5Dps5B7RCHTZyE9opAeUUhqFJIalRhRiRGVpEYlqUF2lkZ2llbJ9FnJ9El2llbB9OkB9AgPQiAlkBEIGOEhEigRKBOoEAikhguYPl2EQEqOB6ZPF9AjXCKBEoEygYgRQowgO0snO0snO0snO0tXMH26RgKNG5H0AiWXBsoEKrNQai9EBVBnZ5mDnKGssYHGjch2+cvNqfncV2dnmYudoRL+v+THB983L7vN18ft6SPop++97e/On0g/Pjz8eP79neNzfwI=",
  "file_map": {
    "27": {
      "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constraint the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = crate::field::bn254::decompose_hint(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n",
      "path": "std/hash/mod.nr"
    },
    "57": {
      "source": "use dep::std;\n\nglobal N: u32 = 3; // 3 digits\nglobal K: u32 = 10; // Digits 0 to 9\n\nfn main(\n    secret: [u32; 3],             // Private\n    salt: Field,                  // Private\n    guess: [u32; 3],              // Private input, returned as public\n    hash: Field,                  // Private input, returned as public\n    acertos: u32,                 // Private input, returned as public\n    permutados: u32,              // Private input, returned as public\n    erros: u32                    // Private input, returned as public\n) -> pub ([u32; 3], Field, u32, u32, u32) {\n    // 1. Verify Commitment (Secret + Salt)\n    // Using Pedersen because Poseidon was not found in std::hash\n    let computed_hash = std::hash::pedersen_hash([\n        secret[0] as Field, \n        secret[1] as Field, \n        secret[2] as Field, \n        salt\n    ]);\n    assert(computed_hash == hash);\n\n    // 2. Performant Mastermind Logic (Frequency Counting)\n    let mut count_acertos: u32 = 0;\n    let mut secret_counts: [u32; 10] = [0; 10];\n    let mut guess_counts: [u32; 10] = [0; 10];\n\n    // Identify exact matches and count frequencies for the rest\n    for i in 0..N {\n        if secret[i] == guess[i] {\n            count_acertos += 1;\n        } else {\n            secret_counts[secret[i]] += 1;\n            guess_counts[guess[i]] += 1;\n        }\n    }\n\n    // Calculate permutations (minimum between frequencies)\n    let mut count_permutados: u32 = 0;\n    for i in 0..K {\n        let sc = secret_counts[i];\n        let gc = guess_counts[i];\n        count_permutados += if sc < gc { sc } else { gc };\n    }\n\n    let count_erros = N - count_acertos - count_permutados;\n\n    // 3. Final Validation\n    assert(count_acertos == acertos);\n    assert(count_permutados == permutados);\n    assert(count_erros == erros);\n\n    // Return public inputs to expose them\n    (guess, hash, acertos, permutados, erros)\n}",
      "path": "/l/disk0/alisson/Documentos/Projetos/Stellar-Game-Studio/contracts/pass/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "verification_key": "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"
}